# production_counter.py - –°—á–µ—Ç—á–∏–∫ –ø—Ä–æ–∏–∑–≤–æ–¥—Å—Ç–≤–∞ —Å –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–µ–π –≤ 1C
from sqlalchemy.orm import sessionmaker
from datetime import datetime, timedelta
import time
import json
import requests
from collections import deque
from models import ProductionBatch, Product, DetectionEvent
import logging


class ProductionCounter:
    """–°—á–µ—Ç—á–∏–∫ –ø—Ä–æ–∏–∑–≤–æ–¥—Å—Ç–≤–∞ —Å —É—á–µ—Ç–æ–º —Ç–∏–ø–æ–≤ –ø—Ä–æ–¥—É–∫—Ü–∏–∏"""

    def __init__(self, db_session, oven_id):
        self.db_session = db_session
        self.oven_id = oven_id
        self.current_batch = None
        self.current_product = None

        # –ú–∞–ø–ø–∏–Ω–≥ –º–∞—Ä–∫–µ—Ä–æ–≤ –Ω–∞ –ø—Ä–æ–¥—É–∫—Ç—ã
        self.marker_to_product = self._load_marker_mapping()

        # –í–∞–ª–∏–¥–∞—Ü–∏—è –ø–æ–¥—Å—á–µ—Ç–∞
        self.validation_window = 60  # —Å–µ–∫—É–Ω–¥ –¥–ª—è –≤–∞–ª–∏–¥–∞—Ü–∏–∏
        self.last_counts = deque(maxlen=10)

        # –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å 1C
        self.c1_config = self._load_1c_config()

        # –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
        logging.basicConfig(level=logging.INFO)
        self.logger = logging.getLogger(f"ProductionCounter_Oven_{oven_id}")

        self.logger.info(f"–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω —Å—á–µ—Ç—á–∏–∫ –¥–ª—è –ø–µ—á–∏ {oven_id}")

    def _load_marker_mapping(self):
        """–ó–∞–≥—Ä—É–∑–∫–∞ –º–∞–ø–ø–∏–Ω–≥–∞ –º–∞—Ä–∫–µ—Ä–æ–≤ –Ω–∞ –ø—Ä–æ–¥—É–∫—Ç—ã –∏–∑ –ë–î"""
        products = self.db_session.query(Product).all()
        mapping = {}

        for product in products:
            if product.marker_shape:
                mapping[product.marker_shape] = product

        self.logger.info(f"–ó–∞–≥—Ä—É–∂–µ–Ω–æ {len(mapping)} –º–∞–ø–ø–∏–Ω–≥–æ–≤ –º–∞—Ä–∫–µ—Ä–æ–≤")
        return mapping

    def _load_1c_config(self):
        """–ó–∞–≥—Ä—É–∑–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –¥–ª—è –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ —Å 1C"""
        config_file = '1c_config.json'
        default_config = {
            'enabled': False,
            'api_url': 'http://localhost:8080/api/production',
            'auth_token': '',
            'timeout': 30,
            'retry_attempts': 3
        }

        try:
            if os.path.exists(config_file):
                with open(config_file, 'r', encoding='utf-8') as f:
                    config = json.load(f)
                self.logger.info("–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è 1C –∑–∞–≥—Ä—É–∂–µ–Ω–∞")
            else:
                config = default_config
                self.logger.warning("–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è 1C –Ω–µ –Ω–∞–π–¥–µ–Ω–∞, –∏—Å–ø–æ–ª—å–∑—É–µ–º –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é")
        except Exception as e:
            config = default_config
            self.logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ 1C: {e}")

        return config

    def process_detections(self, bread_detections, marker_detections, tracked_objects, timestamp):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –¥–µ—Ç–µ–∫—Ü–∏–∏"""
        # –û–±—Ä–∞–±–æ—Ç–∫–∞ –º–∞—Ä–∫–µ—Ä–æ–≤ - —Å–º–µ–Ω–∞ —Ç–∏–ø–∞ –ø—Ä–æ–¥—É–∫—Ü–∏–∏
        for marker in marker_detections:
            if self.handle_marker_detection(marker, timestamp):
                break  # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –ø–µ—Ä–≤—ã–π –Ω–∞–π–¥–µ–Ω–Ω—ã–π –º–∞—Ä–∫–µ—Ä

        # –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–¥—Å—á–µ—Ç–∞ —Ö–ª–µ–±–∞
        if self.current_batch and tracked_objects:
            self.update_batch_count(tracked_objects, timestamp)

    def handle_marker_detection(self, marker, timestamp):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è –º–∞—Ä–∫–µ—Ä–∞ - —Å–º–µ–Ω–∞ —Ç–∏–ø–∞ –ø—Ä–æ–¥—É–∫—Ü–∏–∏"""
        marker_shape = (marker.get('class_name') or '').lower()

        if marker_shape in self.marker_to_product:
            product = self.marker_to_product[marker_shape]

            # –ó–∞–≤–µ—Ä—à–∞–µ–º —Ç–µ–∫—É—â—É—é –ø–∞—Ä—Ç–∏—é
            if self.current_batch:
                self.finish_current_batch()

            # –ù–∞—á–∏–Ω–∞–µ–º –Ω–æ–≤—É—é –ø–∞—Ä—Ç–∏—é
            self.start_new_batch(product, timestamp)
            return True
        else:
            self.logger.warning(f"–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –º–∞—Ä–∫–µ—Ä: {marker_shape}")
            return False

    def start_new_batch(self, product, timestamp):
        """–ù–∞—á–∞–ª–æ –Ω–æ–≤–æ–π –ø–∞—Ä—Ç–∏–∏ –ø—Ä–æ–∏–∑–≤–æ–¥—Å—Ç–≤–∞"""
        try:
            self.current_batch = ProductionBatch(
                oven_id=self.oven_id,
                product_id=product.id,
                start_time=datetime.fromtimestamp(timestamp)
            )
            self.current_product = product

            self.db_session.add(self.current_batch)
            self.db_session.commit()

            self.logger.info(f"ü•ñ –ù–æ–≤–∞—è –ø–∞—Ä—Ç–∏—è: {product.name} –Ω–∞ –ø–µ—á–∏ {self.oven_id}")

            # –ó–∞–ø–∏—Å—ã–≤–∞–µ–º —Å–æ–±—ã—Ç–∏–µ –≤ –ª–æ–≥
            self._log_detection_event('batch_started', timestamp, product.name)

        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –Ω–æ–≤–æ–π –ø–∞—Ä—Ç–∏–∏: {e}")
            self.db_session.rollback()

    def update_batch_count(self, tracked_objects, timestamp):
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—á–µ—Ç—á–∏–∫–∞ –ø–∞—Ä—Ç–∏–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ç—Ä–µ–∫–∏–Ω–≥–∞"""
        if not self.current_batch:
            return

        try:
            # –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ–º –æ–±—ä–µ–∫—Ç—ã, –∫–æ—Ç–æ—Ä—ã–µ –±—ã–ª–∏ —É—á—Ç–µ–Ω—ã —Ç—Ä–µ–∫–µ—Ä–æ–º
            new_bread_count = 0
            new_defect_count = 0

            for obj_id, obj_data in tracked_objects.items():
                if obj_data.get('counted', False) and obj_data.get('class_name') == 'bread':
                    new_bread_count += 1

                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ –±—Ä–∞–∫ (–µ—Å–ª–∏ –µ—Å—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è)
                    if obj_data.get('is_defective', False):
                        new_defect_count += 1

            # –û–±–Ω–æ–≤–ª—è–µ–º —Å—á–µ—Ç—á–∏–∫–∏ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –µ—Å—Ç—å –Ω–æ–≤—ã–µ –æ–±—ä–µ–∫—Ç—ã
            if new_bread_count > 0:
                previous_count = self.current_batch.total_count
                self.current_batch.total_count += new_bread_count
                self.current_batch.defect_count += new_defect_count

                # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ä–µ–¥–Ω—é—é —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å —Ç—Ä–µ–∫–∏–Ω–≥–∞
                confidences = [obj.get('confidence_history', [0.5])[-1]
                               for obj in tracked_objects.values()
                               if obj.get('counted', False)]

                if confidences:
                    avg_confidence = sum(confidences) / len(confidences)
                    self.current_batch.tracking_confidence = avg_confidence

                self.db_session.commit()

                # –õ–æ–≥–∏—Ä—É–µ–º —Å–æ–±—ã—Ç–∏–µ
                self._log_detection_event('bread_counted', timestamp,
                                          f"+{new_bread_count} (–≤—Å–µ–≥–æ: {self.current_batch.total_count})")

                self.logger.info(f"üìä –ü–æ–¥—Å—á–µ—Ç –æ–±–Ω–æ–≤–ª–µ–Ω: +{new_bread_count} = {self.current_batch.total_count} —à—Ç "
                                 f"(–±—Ä–∞–∫: +{new_defect_count})")

                # –í–∞–ª–∏–¥–∞—Ü–∏—è —Å—á–µ—Ç–∞
                self._validate_count(previous_count, new_bread_count)

        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å—á–µ—Ç—á–∏–∫–∞: {e}")
            self.db_session.rollback()

    def _validate_count(self, previous_count, increment):
        """–í–∞–ª–∏–¥–∞—Ü–∏—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç–∏ –ø–æ–¥—Å—á–µ—Ç–∞"""
        current_count = self.current_batch.total_count

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ –∞–Ω–æ–º–∞–ª—å–Ω—ã–µ —Å–∫–∞—á–∫–∏
        if increment > 20:  # –ë–æ–ª–µ–µ 20 –æ–±—ä–µ–∫—Ç–æ–≤ –∑–∞ —Ä–∞–∑ - –ø–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω–æ
            self.logger.warning(f"‚ö†Ô∏è  –ë–æ–ª—å—à–æ–π —Å–∫–∞—á–æ–∫ –≤ –ø–æ–¥—Å—á–µ—Ç–µ: +{increment}")

        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏—Å—Ç–æ—Ä–∏—é –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ —Ç–µ–Ω–¥–µ–Ω—Ü–∏–π
        self.last_counts.append({
            'timestamp': time.time(),
            'count': current_count,
            'increment': increment
        })

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç—å –ø–æ–¥—Å—á–µ—Ç–∞
        if len(self.last_counts) >= 5:
            recent_increments = [c['increment'] for c in list(self.last_counts)[-5:]]
            avg_increment = sum(recent_increments) / len(recent_increments)

            if increment > avg_increment * 3:  # –¢–µ–∫—É—â–∏–π –ø—Ä–∏—Ä–æ—Å—Ç –≤ 3 —Ä–∞–∑–∞ –±–æ–ª—å—à–µ —Å—Ä–µ–¥–Ω–µ–≥–æ
                self.logger.warning(f"‚ö†Ô∏è  –ü–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω—ã–π –ø—Ä–∏—Ä–æ—Å—Ç: {increment} vs —Å—Ä–µ–¥–Ω–µ–µ {avg_increment:.1f}")

    def finish_current_batch(self):
        """–ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Ç–µ–∫—É—â–µ–π –ø–∞—Ä—Ç–∏–∏"""
        if not self.current_batch:
            return

        try:
            self.current_batch.end_time = datetime.now()

            # –§–∏–Ω–∞–ª—å–Ω–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è —Å—á–µ—Ç–∞
            final_count = self._validate_final_count()
            self.current_batch.total_count = final_count

            self.db_session.commit()

            # –õ–æ–≥–∏—Ä—É–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ –ø–∞—Ä—Ç–∏–∏
            self._log_detection_event('batch_finished', time.time(),
                                      f"–ò—Ç–æ–≥–æ: {final_count} —à—Ç, –±—Ä–∞–∫: {self.current_batch.defect_count}")

            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –≤ 1C
            if self.c1_config.get('enabled', False):
                self.send_to_1c(self.current_batch)

            self.logger.info(f"‚úÖ –ü–∞—Ä—Ç–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞: {final_count} —à—Ç, "
                             f"–ø—Ä–æ–¥—É–∫—Ç: {self.current_product.name}, "
                             f"–±—Ä–∞–∫: {self.current_batch.defect_count}")

            # –û—á–∏—â–∞–µ–º —Ç–µ–∫—É—â–∏–µ –¥–∞–Ω–Ω—ã–µ
            self.current_batch = None
            self.current_product = None

        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –ø–∞—Ä—Ç–∏–∏: {e}")
            self.db_session.rollback()

    def _validate_final_count(self):
        """–§–∏–Ω–∞–ª—å–Ω–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –ø–µ—Ä–µ–¥ –æ—Ç–ø—Ä–∞–≤–∫–æ–π –≤ 1C"""
        if not self.current_batch:
            return 0

        current_count = self.current_batch.total_count

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞–∑—É–º–Ω–æ—Å—Ç—å –∏—Ç–æ–≥–æ–≤–æ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞
        batch_duration = (datetime.now() - self.current_batch.start_time).total_seconds() / 60  # –º–∏–Ω—É—Ç—ã

        if batch_duration > 0:
            items_per_minute = current_count / batch_duration

            # –ï—Å–ª–∏ –±–æ–ª—å—à–µ 50 —à—Ç—É–∫ –≤ –º–∏–Ω—É—Ç—É - –ø–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω–æ
            if items_per_minute > 50:
                self.logger.warning(f"‚ö†Ô∏è  –í—ã—Å–æ–∫–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å –ø—Ä–æ–∏–∑–≤–æ–¥—Å—Ç–≤–∞: {items_per_minute:.1f} —à—Ç/–º–∏–Ω")

            # –ï—Å–ª–∏ –º–µ–Ω—å—à–µ 1 —à—Ç—É–∫–∏ –≤ 5 –º–∏–Ω—É—Ç - —Ç–æ–∂–µ —Å—Ç—Ä–∞–Ω–Ω–æ
            if items_per_minute < 0.2 and current_count > 0:
                self.logger.warning(f"‚ö†Ô∏è  –û—á–µ–Ω—å –Ω–∏–∑–∫–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å –ø—Ä–æ–∏–∑–≤–æ–¥—Å—Ç–≤–∞: {items_per_minute:.1f} —à—Ç/–º–∏–Ω")

        return current_count

    def _log_detection_event(self, event_type, timestamp, details):
        """–õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–æ–±—ã—Ç–∏—è –¥–µ—Ç–µ–∫—Ü–∏–∏ –≤ –ë–î"""
        try:
            if self.current_batch:
                event = DetectionEvent(
                    batch_id=self.current_batch.id,
                    timestamp=datetime.fromtimestamp(timestamp),
                    event_type=event_type,
                    confidence=0.95,  # –ë–∞–∑–æ–≤–∞—è —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å
                    bbox_data=json.dumps({'details': details})
                )
                self.db_session.add(event)
                self.db_session.commit()
        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è —Å–æ–±—ã—Ç–∏—è: {e}")

    def send_to_1c(self, batch):
        """–û—Ç–ø—Ä–∞–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö –≤ 1C —á–µ—Ä–µ–∑ REST API"""
        if not self.c1_config.get('enabled', False):
            self.logger.info("–ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å 1C –æ—Ç–∫–ª—é—á–µ–Ω–∞")
            return False

        try:
            # –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏
            data = {
                'oven_id': batch.oven_id,
                'product_code': batch.product.code,
                'product_name': batch.product.name,
                'quantity': batch.total_count,
                'defects': batch.defect_count,
                'start_time': batch.start_time.isoformat(),
                'end_time': batch.end_time.isoformat() if batch.end_time else None,
                'tracking_confidence': batch.tracking_confidence,
                'batch_id': batch.id
            }

            # –ó–∞–≥–æ–ª–æ–≤–∫–∏ –∑–∞–ø—Ä–æ—Å–∞
            headers = {
                'Content-Type': 'application/json',
                'Authorization': f'Bearer {self.c1_config.get("auth_token", "")}'
            }

            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ
            url = self.c1_config.get('api_url')
            timeout = self.c1_config.get('timeout', 30)

            self.logger.info(f"üì§ –û—Ç–ø—Ä–∞–≤–∫–∞ –≤ 1C: {batch.total_count} —à—Ç {batch.product.name}")

            response = requests.post(
                url,
                json=data,
                headers=headers,
                timeout=timeout
            )

            if response.status_code == 200:
                self.logger.info("‚úÖ –î–∞–Ω–Ω—ã–µ —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã –≤ 1C")
                return True
            else:
                self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤ 1C: {response.status_code} - {response.text}")
                return False

        except requests.exceptions.Timeout:
            self.logger.error("‚ùå –¢–∞–π–º–∞—É—Ç –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –≤ 1C")
            return False
        except requests.exceptions.ConnectionError:
            self.logger.error("‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ 1C")
            return False
        except Exception as e:
            self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤ 1C: {e}")
            return False

    def get_current_batch_info(self):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Ç–µ–∫—É—â–µ–π –ø–∞—Ä—Ç–∏–∏"""
        if not self.current_batch:
            return None

        duration = (datetime.now() - self.current_batch.start_time).total_seconds() / 60

        return {
            'batch_id': self.current_batch.id,
            'product_name': self.current_product.name if self.current_product else 'Unknown',
            'product_code': self.current_product.code if self.current_product else 'N/A',
            'start_time': self.current_batch.start_time.isoformat(),
            'duration_minutes': round(duration, 1),
            'total_count': self.current_batch.total_count,
            'defect_count': self.current_batch.defect_count,
            'tracking_confidence': self.current_batch.tracking_confidence or 0.0
        }

    def get_statistics(self, hours=24):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø—Ä–æ–∏–∑–≤–æ–¥—Å—Ç–≤–∞ –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ N —á–∞—Å–æ–≤"""
        try:
            start_time = datetime.now() - timedelta(hours=hours)

            # –ó–∞–ø—Ä–æ—Å –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã—Ö –ø–∞—Ä—Ç–∏–π
            batches = self.db_session.query(ProductionBatch).filter(
                ProductionBatch.oven_id == self.oven_id,
                ProductionBatch.start_time >= start_time,
                ProductionBatch.end_time != None
            ).all()

            if not batches:
                return {
                    'total_batches': 0,
                    'total_items': 0,
                    'total_defects': 0,
                    'products': {}
                }

            # –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
            total_items = sum(batch.total_count for batch in batches)
            total_defects = sum(batch.defect_count for batch in batches)

            # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ –ø—Ä–æ–¥—É–∫—Ç–∞–º
            products_stats = {}
            for batch in batches:
                product_name = batch.product.name
                if product_name not in products_stats:
                    products_stats[product_name] = {
                        'batches': 0,
                        'items': 0,
                        'defects': 0
                    }

                products_stats[product_name]['batches'] += 1
                products_stats[product_name]['items'] += batch.total_count
                products_stats[product_name]['defects'] += batch.defect_count

            return {
                'total_batches': len(batches),
                'total_items': total_items,
                'total_defects': total_defects,
                'defect_rate': (total_defects / total_items * 100) if total_items > 0 else 0,
                'products': products_stats,
                'period_hours': hours
            }

        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏: {e}")
            return None

    def force_finish_batch(self, reason="Manual finish"):
        """–ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Ç–µ–∫—É—â–µ–π –ø–∞—Ä—Ç–∏–∏"""
        if self.current_batch:
            self.logger.info(f"üõë –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ –ø–∞—Ä—Ç–∏–∏: {reason}")
            self._log_detection_event('batch_force_finished', time.time(), reason)
            self.finish_current_batch()
            return True
        return False

    def reset_batch_count(self):
        """–°–±—Ä–æ—Å —Å—á–µ—Ç—á–∏–∫–∞ —Ç–µ–∫—É—â–µ–π –ø–∞—Ä—Ç–∏–∏ (–¥–ª—è –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è –æ—à–∏–±–æ–∫)"""
        if self.current_batch:
            old_count = self.current_batch.total_count
            self.current_batch.total_count = 0
            self.current_batch.defect_count = 0
            self.db_session.commit()

            self.logger.warning(f"üîÑ –°—á–µ—Ç—á–∏–∫ –ø–∞—Ä—Ç–∏–∏ —Å–±—Ä–æ—à–µ–Ω: {old_count} -> 0")
            self._log_detection_event('batch_count_reset', time.time(), f"–°–±—Ä–æ—à–µ–Ω —Å—á–µ—Ç—á–∏–∫: {old_count}")
            return True
        return False